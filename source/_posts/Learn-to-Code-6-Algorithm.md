title: 'Learn to Code 6: Algorithm'
visible: show
date: 2022-07-28 00:02:54
tags: [programming, coding, program, code, class, course, education, teaching]
category: Programming
---
想像一下! 如果在前面車子剎車後特斯拉自動車沒辦法在「短時間」內做好計算，判斷了好久才減速，不就有損特斯拉專業又先進的招牌?
為什麼要了解演算法呢? 為什麼要寫出更有效率、用更少資源的程式碼? 如果我們要解決的問題很複雜、程式必須得在一定時間內跑完、或這個問題看起來要花很多資源、或只能花一定的資源就把問題解決。通常，我們就可以先用演算法在寫程式之前，用比較口語的方式來設計要用什麼步驟、什麼順序、什麼邏輯來解決一個問題。好的演算法可以讓解決方案變得很簡單、很有效率，或是花少少的資源就可以把問題解決；糟糕的演算法甚至可以讓程式跑幾天都跑不出來!  所以，特斯拉自動車可以在路上隨時掌握周邊車子的位置、距離還有速度。前面的車子一剎車，特斯拉可以根據距離、車速還有各種因素在一定時間內把速度降到 0。這種在「某個最長的耗時之下達成目標」的概念，就是演算法講的「時間複雜度」 - time complexity

## 複雜度
談到演算法，我們都會提到 time complexity (時間複雜度) 或 space complexity (空間複雜度)，標記會像「O(n)」這樣來表示時間或資源花最兇的程度。O 念作 big-O，指的是極限的概念，也就是最糟糕的程度到哪裡；複雜度在這裡指的是「有多糟」。常見的複雜度有幾個層級：
1. O(1)：代表複雜度不會隨著資料量增加而受到影響
2. O(n)：代表複雜度會隨著資料量增加以線性成長
3. O(n log(n))：代表複雜度一開始會隨著資料量增加而遽增，但隨著資料量持續增加，複雜度的成長會趨緩
4. O(n<sup>2</sup>)：代表資料量如果不斷成長，複雜度會跟著以指數上升

## 經典演算法介紹：Bubble sort
來舉個例子吧！今天有一列身高都不一樣的小學生在排隊下學。有一位老師想把學生的身高照最高排到最低。這位老師先走到隊伍最前面，看最前面兩位學生的身高，如果身高沒有由大到小排就交換兩位學生的位置。看完最前面兩位，就看第二跟第三位、第三跟第四位……一直到最後兩位。如果中間有交換任何學生的位置，老師就會走到最前面，再從前面兩位開始看一輪。一直到老師從最前面走到最後面，中間都沒有交換任何學生為止。
上面用文字描述怎麼把學生「由高排到低」，就是「演算法」。(看需不需要寫得更正式一點)。如果照這樣幫學生調整隊伍，老師排學生的「時間複雜度」會是多少呢?

```cpp
int[] student_heights = {151, 156, 153, 149, 152};
```

Being written…

n = 5

n + (n - 1) + (n - 2) + (n - 3) + (n - 4)
= 5n - 10
= n^2 - 2n
= n(n - 2)



解答：
從第 0 個元素開始，如果目前的元素比下一個元素還要小，那就把兩個房間的數值做交換，一直換到倒數第二個為止
假設這次迭代過程中有任何交換行為出現，那就重作一次第 1. 步。如果這次迭代過程完全沒有交換行為出現，那就算排序完成
Bubble sort 沒有寫程式，程式的部分是作業，交給你去思索 XD
